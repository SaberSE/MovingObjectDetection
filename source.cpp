//opencv
#include <opencv\cv.h>
#include <opencv\highgui.h>
#include <opencv2\highgui.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <opencv2\videoio.hpp>
#include <opencv2\highgui.hpp>
#include <opencv2\opencv.hpp>
#include <opencv2\core\core.hpp>
#include <opencv2\opencv.hpp>
#include <opencv2\video.hpp>
#include <opencv2\features2d.hpp>
//C
#include <stdio.h>
//C++
#include <sstream>
#include <iostream>
#include <stdlib.h>

using namespace cv;
using namespace std;

// Global variables

//our sensitivity value 
const static int SENSITIVITY_VALUE = 1;
//size of blur used to smooth the intensity image 
const static int BLUR_SIZE = 1;

Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//thresholded difference image (for use in findContours() function)
Mat thresholdImage;
Mat temp;
Ptr<BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor
Ptr<BackgroundSubtractorMOG2> pMOG3; //MOG2 Background subtractor
int keyboard; //input from keyboard
//these two vectors needed for output of findContours
vector< vector<Point> > contours;
vector<Vec4i> hierarchy;
RNG rng(12345);



/** Function Headers */
void processVideo(char* videoFilename);

/**
* @function main
*/
int main(int argc, char* argv[])
{
	//create Background Subtractor objects
	//with pMOG2 and pMOG3 I cut off shadows
	pMOG2 = createBackgroundSubtractorMOG2(500, 900, true); //MOG2 approach
	pMOG2->setShadowValue(0);
	pMOG2->setShadowThreshold(0);
	pMOG2->setNMixtures(20);

	pMOG3 = createBackgroundSubtractorMOG2(500,100, false); 
	pMOG3->setShadowValue(255);
	pMOG3->setNMixtures(20);
	pMOG3->setShadowThreshold(1);

	//input data coming from a video
	processVideo("video.mp4");

}


/**
* @function processVideo
*/
void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}


	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}


		//Documentation part 2
		frame.copyTo(temp);
		//update the background model
		pMOG2->apply(temp, fgMaskMOG2);
		//imshow("First Shadow Cut", fgMaskMOG2);
		

		//Documentation part 3
		//In this part I made some transformation with man-sized shape with no shadow, I grow pixels with dilate so the holes are filled, but it has no more man shape. I will use it as a mask later.
		//Search for countours
		findContours(fgMaskMOG2, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));
		/// Draw polygonal contour
		Mat drawing = Mat::zeros(fgMaskMOG2.size(), CV_8UC3);
		for (int i = 0; i < contours.size(); i++)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			drawContours(drawing, contours, i, color, -1, 8, vector<Vec4i>(), 0, Point());
		}
		//imshow("Filled Contours", drawing);
		Mat grey;
		cvtColor(drawing, grey, CV_RGB2GRAY);
		//imshow("Grey", grey);
		Mat dilated;
		dilate(grey, dilated, Mat(), Point(-1, -1), 55, 0, 0);
		//imshow("Dilated", dilated);
		Mat blur;
		cv::blur(dilated, blur, cv::Size(11, 11));
		threshold(blur, thresholdImage, SENSITIVITY_VALUE, 255, THRESH_BINARY);
		//imshow("Threshold", thresholdImage);


		//Documentation Part 4
		Mat fgMaskMOG3;
		//update the background model
		pMOG3->apply(frame, fgMaskMOG3);
		//imshow("PMOG3", fgMaskMOG3);


		//Documentation Part 5, mix fgMaskMOG3 with thresholdImage, so I can ignore, shadows, noise and holes
		Mat differenceImage;
		//perform frame differencing with the sequential images. This will output an "intensity image"
		//do not confuse this with a threshold image, we will need to perform thresholding afterwards.
		cv::multiply(thresholdImage, fgMaskMOG3, differenceImage);
		//imshow("Difference", differenceImage);


		//Documentation Part 6
		//Mask the original video with differenceImage, so I get the walking people with black background.
		Mat dst;
		//Set every pixel to black
		dst = Scalar::all(0);
		frame.copyTo(dst, differenceImage);
		//imshow("Dst", dst);


		//Documentation Part 7
		//Use this image to find the ROI with contours and sign it with bounding box
		//find contours of filtered image using openCV findContours function
		findContours(differenceImage, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));// retrieves external contours
		/// Approximate contours to polygons + get bounding rects
		vector<Rect> boundRect(contours.size());
		//vector<Point2f>center(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
			//Create best fitting bounding box
			boundRect[i] = boundingRect(Mat(contours[i]));
			Rect R = boundingRect(contours[i]);
			//Create ROI
			Mat ROI = dst(R);
			//I needed to set a condition so the program skip miniture bonding boxes
			if (ROI.rows>100 || ROI.cols > 100){
				//write ROI (walking people with black background) to cropped.png
				imwrite("cropped.png", ROI);
				//Create Mask (ROI with black background and white man shape)
				Mat maskROI = differenceImage(R);
				// let's create a new image now
				Mat dst2(ROI.rows, ROI.cols, CV_8UC3);
				//Convert ROI and DST2 to have ALPHA parameter which is responsible for transparency
				cvtColor(dst2, dst2, CV_RGB2BGRA);
				cvtColor(ROI, ROI, CV_RGB2BGRA);
				// set background to transparent		
				dst2 = cv::Scalar(255, 255, 255, 0);
				//Mask ROI with maskROI and copy the result (only the man shape without backround) to the transparent image
				ROI.copyTo(dst2, maskROI);
				//save the result to dst.png
				imwrite("dst.png", dst2);
				//imshow("transparent", dst2);
				//imshow("maskROI", maskROI);
			}
			else
			{
				continue;
			}
		}


		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));


		//show the current frame
		//imshow("Frame", frame);

		//get the input from the keyboard
		keyboard = waitKey(30);
	
	}
	//delete capture object
	capture.release();
}
